

# S、X锁

InnoDB实现了行级锁，可以分为两种类型：共享（S）锁定和排他（X）锁定。

- 共享（S）锁允许持有该锁的事务读取一行，所有又叫读锁
- 排他（X）锁允许持有该锁的事务更新或删除行，所以又叫写锁。



## S锁

其他人可以上S锁，不能上X锁

多个事务并发执行时，如果事务T1在某一行r上持有**共享（S）锁**，那么事务T2的对这行r的锁请求将按以下方式处理：

1. T2对S锁的请求可以立即获得批准。T1和T2都在r上保持了S锁。
2. T2对X锁的请求不能获取批准。

这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

## X锁

如果事务T1在某一行`r`上拥有**排他（X）锁**，则事务T2不能获取锁（不论是**S锁**还是**X锁**）



# 乐观、悲观锁

乐观锁是乐观的认为每次都不会发生冲突，只会在更新的时候检查要更新的值有没有被别人修改过，因为没有加锁，所以乐观锁又叫**无锁**。在数据库中一般是用MVCC实现乐观锁，在Java中用CAS实现乐观锁。

至于悲观锁就是悲观的认为每次都会发生冲突，所以每次修改都需要加锁。





# 行锁

行锁是MySQL中粒度最细的一种锁，每次只锁住要操作的那一行。实现复杂，支持的并发度高。只有InnoDB支持行锁。

行锁也分为共享（S）锁和排他（X）锁。行锁是对索引的锁定。例如`SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE`，防止任何其他事务插入，更新或删除t.c1值为10的行。行锁始终锁定索引，对于没有创建索引的表，InnoDB创建一个隐藏的聚簇索引并将该索引用于行锁。

行锁的特点是实现复杂，并发度高。加锁慢，开销大。会出现死锁





# 意向锁（Intention Locks）

InnoDB支持多种粒度锁定，允许行锁和表锁并存。为了使在多个粒度级别上的锁定变得切实可行，InnoDB实现了意图锁。意向锁是表级锁，表示事务稍后对表中的行需要上哪种类型的锁（共享锁或排他锁）。有两种类型的意图锁：

* 意向共享锁（IS）表示事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。
* 意向排他锁（IX）表示事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。


> Intention locks do not block anything except full table requests (for example, LOCK TABLES … WRITE). The main purpose of intention locks is to show that someone is locking a row, or going to lock a row in the table.
> **意向锁**不会阻止任何其他请求，除了（锁定）全表请求（例如`LOCK TABLES ... WRITE`）外。**意向锁**定的主要目的是：声明已经有事务**正在锁定**表中的行，或者**即将锁定**表中的行。

声明表中的行正在被锁定或者即将被锁定，用于事务A想给整个表上 X锁时，判断这个 X锁能不能上。



# 间隙锁（Gap Locks）

间隙锁锁定的是索引记录之间的间隙，或者在第一个或最后一个索引记录之前的间隙。例如`SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE`，可以防止其他事务将t.c1为15的记录插入表中，因为这两个值之间的间隙是被锁定的。

间隙可能跨越单个索引值，多个索引值，甚至为空。

间隙锁的唯一目的是**仅防止其他事务在间隙中插入数据**。间隙锁可以共存。一个事务执行的间隙锁，不会阻止另一事务对相同的间隙进行间隙锁定。


# Next-Key Locks

Next-Key Locks是索引记录上的**行锁**和**间隙锁**的组合。如果一个session在索引中的记录R上具有共享或排他锁，则另一session不能按照索引顺序在R之前的间隙中插入新的索引记录。

默认情况下，InnoDB设置的事务隔离级别是REPEATABLE READ。在这种情况下，InnoDB使用Next-Key Locks进行搜索和索引扫描，这可以防止幻读（虚读）。关于MySQL隔离级别相关的问题，







