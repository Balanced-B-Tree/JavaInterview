[toc]



[MySQL存储引擎MyISAM和InnoDB底层索引结构_@子敬的博客-CSDN博客_myisam索引结构](https://blog.csdn.net/u010922732/article/details/82994253?utm_source=app&app_version=4.15.2)



不要过度建索引，只保持所需的索引。每个额外的索引都要占用额外的磁盘空间，并降低写操作的 性能。 在修改表的内容时，索引必须进行更新，有时可能需要重构，因此，索引越多，所花的时间越长。

MySQL 只对一下操作符才使用索引： <,<=,=,>,>=,between,in 以及某些时候的 like(不以通配符%或_开头的情形)。





# 聚簇、非聚簇索引

InnoDB中主键所建立的是聚簇索引，而唯一索引、普通索引、前缀索引等都是二级索引。

![image-20210730210627956](%E7%B4%A2%E5%BC%95.assets/image-20210730210627956.png)

二级索引：指的是非主键索引

![image-20210730210700213](%E7%B4%A2%E5%BC%95.assets/image-20210730210700213.png)

## 聚簇索引

innoDB的key值，最好用自增，可以避免数据的插入。因为在InnoDB中，数据是顺序存储的，就像数组一样，插入数据时，需要像数组一样修改文件。

1. 能提升IO密集型应用性能（范围查询）：因为，聚簇索引中，数据是顺序存储，能够利用局部性原理。在非聚簇索引中，数据不是顺序存储，无法使用局部性原理
2. 减少一次访盘，增加查询速度
2. row的移动，不影响二级索引：二级索引中，叶子结点存储的是 从键-主键的映射，在根据从键找到主键后，需要拿着主键去“主键索引”中再进行一次查询。（select * 会导致 查询二级索引）



## B+与B的区别

1. 在B树中，你可以将键和值存放在内部节点和叶子节点，但在B+树中，内部节点都是键，没有值。叶子节点同时存放键和值
2. B+树的叶子节点有一条链相连，而B+树的叶子节点各自独立。



使用B+树的好处：

1. 从内存块上来说：一个内存块能存放更多的key，有利于减少磁盘与内存块的交互
2. 从范围查询上来说

数据库的数据读取都是需要进行代价巨大的磁盘IO操作，因此，更快地缩小范围和更少的读取次数是数据库需要关注的重点。









# 索引分类

索引我们分为四类来讲**单列索引**(普通索引，唯一索引，主键索引)、**组合索引**、**全文索引**、**空间索引**、

1. 单列索引：一个索引只包含单个列，但一个表中可以有多个单列索引。 这里不要搞混淆了。
	1. 普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。
	2. 唯一索引：索引列中的值必须是唯一的，但是允许为空值，
	3. 主键索引（也称聚簇索引）：是一种特殊的唯一索引，不允许有空值。（主键约束，就是一个主键索引）

2. 组合索引：在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。例如，这里由id、name和age3个字段构成的索引，索引行中就按id/name/age的顺序存放，索引可以索引下面字段组合(id，name，age)、(id，name)或者(id)。如果要查询的字段不构成索引最左面的前缀，那么就不会是用索引，比如，age或者（name，age）组合就不会使用索引查询

3. 全文索引：全文索引，只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引，介绍了要求，说说什么是全文索引，就是在一堆文字中，通过其中的某个关键字等，就能找到该字段所属的记录行，比如有"你是个大煞笔，二货 ..." 通过大煞笔，可能就可以找到该条记录。这里说的是可能，因为全文索引的使用涉及了很多细节，我们只需要知道这个大概意思。

4. 空间索引：空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有四种，GEOMETRY、POINT、LINESTRING、POLYGON。在创建空间索引时，使用SPATIAL关键字。要求，引擎为MyISAM，创建空间索引的列，必须将其声明为NOT NULL。可能跟游戏开发有关。



## 覆盖索引

[MySQL 覆盖索引详解 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903967365791752)

覆盖索引，即一次查找，就能找到想要的数据，无需回表。

对于使用了覆盖索引的查询，在查询前面使用`explain`，输出的extra列会显示为`using index`。

比如`user_like` 用户点赞表，组合索引为`(user_id, blog_id)`，`user_id`和`blog_id`都不为`null`。

~~~sql
explain select blog_id from user_like where user_id = 13;
~~~



### 回表

**所谓回表查询**，需要**扫描两次索引 B+ 树**，所以很显然它的性能较扫一遍索引树更低。

假设表tbl有a,b,c三个字段，其中a是主键，b上建了索引，然后编写sql语句

~~~sql
SELECT * FROM tbl WHERE a=1
~~~

这样不会产生回表，因为所有的数据在a的索引树中均能找到



~~~sql
SELECT * FROM tbl WHERE b=1
~~~

这样就会产生回表，因为通过 b的索引，只能找到对应的主键 a。但是，我们要找到是所有的数据 `a,b,c`，因此需要再去主键索引 a那里寻找



## 联合索引

也称为组合索引，(column1, column2, column3.....)



## 前缀索引？

有时需要在很长的字符列上创建索引，这会造成索引特别大且慢。使用前缀索引可以避免这个问题。

前缀索引是指对文本或者字符串的前几个字符建立索引，这样索引的长度更短，查询速度更快。

创建前缀索引的关键在于选择足够长的前缀以**保证较高的索引选择性**。索引选择性越高查询效率就越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的数据行。

建立前缀索引的方式：

~~~sql
// email列创建前缀索引
ALTER TABLE table_name ADD KEY(column_name(prefix_length));
~~~









# 建立索引的原则

- 索引列的**区分度越高**，索引的效果越好。比如使用性别这种区分度很低的列作为索引，效果就会很差。
- 尽量使用**短索引**，对于较长的字符串进行索引时应该指定一个较短的前缀长度，因为较小的索引涉及到的磁盘I/O较少，查询速度更快。
- 索引不是越多越好，每个索引都需要额外的物理空间，维护也需要花费时间。
- 利用**最左前缀原则**。

![image-20210730212324231](%E7%B4%A2%E5%BC%95.assets/image-20210730212324231.png)



# 建立索引的情况

1. **主键**：主键自动建立唯一索引P
2. **频繁使用的**：频繁作为查询条件的字段应该创建索引

3. **外键**：查询中与其它表关联的字段，外键关系建立索引

4. **组合索引**：单键/组合索引的选择问题，组合索引性价比更高

5. **order by**：查询中排序的字段（被order by的），排序字段若通过索引去访问将大大提高排序速度
6. **group by**：查询中统计或者分组字段（group by）



不用建立索引的：

1. 表记录太少
2. 经常增删改的表或者字段
3. Where条件里用不到的字段不创建索引
4. 过滤性不好的不适合建索引



# 索引失效的情况

1. 查询条件包含or，可能导致索引失效

2. 如何字段类型是字符串，where时一定用引号括起来，否则索引失效

3. like通配符可能导致索引失效。

4. 联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。

5. 在索引列上使用mysql的内置函数，索引失效。

6. 对索引列运算（如，+、-、*、/），索引失效。

7. 索引字段上使用（！= 或者 < >，not in）时，可能会导致索引失效。

8. 索引字段上使用is null， is not null，可能导致索引失效。

9. 左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。

10. mysql估计使用全表扫描要比使用索引快,则不使用索引。



