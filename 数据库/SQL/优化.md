

在进行优化时，将外关联，变为内关联，是因为可以减少执行引擎执行的次数，降低存储引擎读取的次数



# 大表优化

当MySQL单表记录数过大时，数据库的性能会明显下降，一些常见的优化措施如下：

- 限定数据的范围。比如：用户在查询历史信息的时候，可以控制在一个月的时间范围内；
- 读写分离：经典的数据库拆分方案，主库负责写，从库负责读；
- 通过分库分表的方式进行优化，主要有垂直拆分和水平拆分。



# 分库分表

[聊聊分库分表 (qq.com)](https://mp.weixin.qq.com/s/VZXunsXEWAdRr3bup7L9yA)

## 瓶颈

### IO瓶颈

第一种：磁盘读IO瓶颈，热点数据太多，数据库缓存放不下，每次查询时会产生大量的IO，降低查询速度 -> 分库和垂直分表。

第二种：网络IO瓶颈，请求的数据太多，网络带宽不够 -> 分库。



### CPU瓶颈

**第一种**：SQL问题，如SQL中包含join，group by，order by，非索引字段条件查询等，增加CPU运算的操作 -> SQL优化，建立合适的索引，在业务Service层进行业务计算。

**第二种**：单表数据量太大，查询时扫描的行太多，SQL效率低，CPU率先出现瓶颈 -> 水平分表。



## 分表

### 水平分表

IO未瓶颈，CPU瓶颈了

**场景：**系统绝对并发量并没有上来，只是单表的数据量太多，影响了SQL效率，加重了CPU负担，以至于成为瓶颈。

**分析：**表的数据量少了，单次SQL执行效率高，自然减轻了CPU的负担。



### 垂直分表

表内存在大量非热点数据的列，使得每次IO得到的有效数据较少

**场景：**系统绝对并发量并没有上来，表的记录并不多，但是字段多，并且热点数据和非热点数据在一起，**单行数据所需的存储空间较大。以至于数据库缓存的数据行减少**，查询时会去读磁盘数据产生大量的随机读IO，产生IO瓶颈。



分表：可以用列表页和详情页来帮助理解。垂直分表的拆分原则是**将热点数据（可能会冗余经常一起查询的数据）放在一起作为主表，非热点数据放在一起作为扩展表。**这样更多的热点数据就能被缓存下来，进而减少了随机读IO。拆了之后，要想获得全部数据就需要关联两个表来取数据。

但记住，千万别用join，因为join不仅会增加CPU负担并且会讲两个表耦合在一起（必须在一个数据库实例上）。**关联数据，应该在业务Service层做文章**，分别获取主表和扩展表数据然后用关联字段关联得到全部数据。



## 分库

### 水平分库

网络IO瓶颈

**分析：**库多了，io和cpu的压力自然可以成倍缓解。



### 垂直分库









# explain

使用EXPLAIN关键字可以模拟优化器执行SQL套询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈

用处：

- 表的读取顺序
- 哪些索引可以使用
- 数据读取操作的操作类型
- 哪些索引被实际使用
- 表之间的引用
- 每张表有多少行被物理查询



## 字段

在查询中的每个表会输出一行，如果有两个表通过 join 连接查询，那么会输出两行。表的意义相当广泛：可以是子查询、一个 union 结果等。

~~~
mysql> explain select * from actor;
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
|  1 | SIMPLE      | actor | ALL  | NULL          | NULL | NULL    | NULL |    2 | NULL  |
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
~~~





### id 

![image-20211204152205274](%E4%BC%98%E5%8C%96.assets/image-20211204152205274.png)

id表示执行的优先级，相当于权值，权值越大，优先级越高。

id号每个号码，表示一趟独立的查询。一个sql的查询趟数越少越好。

- id相同，执行顺序由上至下
- id不同，如果是子查询，id的序号会递增，id值 越大优先级越高，越先被执行
- id相同不同，同时存在
- 

### select_type 优化用不到

常用的：

| 类型         |                  含义                  |
| :----------- | :------------------------------------: |
| SIMPLE       |  简单SELECT查询，不包含子查询和UNION   |
| PRIMARY      | 复杂查询中的最外层查询，表示主要的查询 |
| SUBQUERY     |    SELECT或WHERE列表中包含了子查询     |
| DERIVED      |     FROM列表中包含的子查询，即衍生     |
| UNION        |         UNION关键字之后的查询          |
| UNION RESULT |        从UNION后的表获取结果集         |



**simple**：简单查询。查询不包含子查询和union

~~~sql
select * from film where id = 2;
~~~



**Primary**：查询中若包含任何复杂的子部分，最外层查询则被标记为Primary



**DERIVED**：在FROM列表中包含的子查询被标记为DERIVED(衍生)，MySQL会递归执行这些子查询,把结果放在临时表里。相当于是临时表

![image-20211204165315124](%E4%BC%98%E5%8C%96.assets/image-20211204165315124.png)



**SUBQUERY**： 在SELECT或WHERE列表中包含了子查询

![image-20211204165442525](%E4%BC%98%E5%8C%96.assets/image-20211204165442525.png)



**DEPENDENT SUBQUERY**：在 SELECT或WHERE列表中包含了子查询,子查询基于外层

![image-20211204165518891](%E4%BC%98%E5%8C%96.assets/image-20211204165518891.png)



**UNCACHEABLE SUBQUREY**：



**UNION**：若第二个SELECT出现在UNION之后，则被标记为UNION;若UNION包含在FROM子句的子查询中,外层SELECT将被标记为: DERIVED

![image-20211204165816246](%E4%BC%98%E5%8C%96.assets/image-20211204165816246.png)



**UNION RESULT**：从UNION 表获取结果的SELECT





### table 优化用不到

该列的值表示输出行所引用的表的名称，比如前面的：t1、t2等表名。

但也可以是以下值之一：

- `<unionM,N>`：具有和id值的行的M并集N。
- `<derivedN>`：用于与该行的派生表结果id的值N。派生表可能来自（例如）FROM子句中的子查询 。
- `<subqueryN>`：子查询的结果，其id值为N





### type（连接类型） 重点

![图片](%E4%BC%98%E5%8C%96.assets/640-20220104192326359)

显示查询使用了何种类型，执行结果从最好到最坏的的顺序是从上到下。

我们需要重点掌握的是下面几种类型：

system（表里只有一行数据）>const（where id=1。能够通过索引直接找到）>eq_ref>ref>range>index>ALL



#### **ALL**：即全表扫描，

意味着mysql需要从头到尾去查找所需要的行。通常情况下这需要增加索引来进行优化了

#### **index**：全索引扫描

和ALL一样，不同就是mysql只需扫描索引树，这通常比ALL快一些。出现index是 sql 使用了索引但是没用通过索引进行过滤，一般是使用了覆盖索引或者是利用索引进行了排序分组。

过滤条件没有用上索引，from和where之间用了索引，但是where之后没有用上索引

#### **range**：利用索引的范围查询

范围扫描通常出现在 in(), between ,> ,<, >= 等操作中。使用一个索引来检索给定范围的行。

#### **index. subquery**：

利用索引来关联子查询，不再全表扫描。就是**子查询使用了索引**

![image-20211204171055075](%E4%BC%98%E5%8C%96.assets/image-20211204171055075.png)



#### index_merge

![image-20211204170921565](file:///Users/helloworld/Library/Mobile%20Documents/iCloud~md~obsidian/Documents/Markdown/%E5%90%8E%E5%8F%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/%E4%BC%98%E5%8C%96.assets/image-20211204170921565.png?lastModify=1641295756)

#### **ref**：联合查询，被驱动表使用非唯一索引扫描；单表，非唯一索引

非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体

唯一索引：对于同一个key，只返回一条数据

非唯一索引：对于同一个key，返回多条数据





#### **eq_ref**：联合查询，被驱动表使用唯一索引

primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。

唯一性索引扫描，对于每个索引键，表中只有一-条记录与之匹配。

![image-20211204170556724](%E4%BC%98%E5%8C%96.assets/image-20211204170556724.png)





#### const：单表，唯一索引

通过一次索引就能找到数据，一般用于主键或唯一索引作为条件的查询sql中，





### possible_keys（可能的索引选择）



### key（实际用到的索引)重点

实际使用的索引。如果为NULL，则没有使用索引

查询中若使用了覆盖索引，则该索引和查询的select字段重叠

**key这一列的作用：看sql语句有没有使用索引。**





### key_len（实际索引的长度）重点

**key_len这一列的作用：看sql语句有没有==充分==使用索引。**



where后面筛选条件命中索引的长度。

![image-20211204172223871](%E4%BC%98%E5%8C%96.assets/image-20211204172223871.png)

数值越大越好

key_len=age的字节长度+name的字节长度=4+1 + ( 20*3+2)=5+62=67



**决定key_len值的三个因素**：

 1.字符集

 2.长度

 3.是否为空 



常用的字符编码占用字节数量如下：

![图片](%E4%BC%98%E5%8C%96.assets/640-20220104193743242)

mysql常用字段占用字节数：

| 字段类型   | 占用字节数 |
| :--------- | :--------: |
| char(n)    |     n      |
| varchar(n) |   n + 2    |
| tinyint    |     1      |
| smallint   |     2      |
| int        |     4      |
| bigint     |     8      |
| date       |     3      |
| timestamp  |     4      |
| datetime   |     8      |

此外，如果字段类型允许为空则加1个字节。











### ref（与索引比较的列）





### rows（预计要检查的行数）

物理扫描的行数，数值越少越好

但这是估计的，最终扫描的行数在这个数值左右



### Extra（附加信息）重点

与 order by，group by有关



重点优化：

#### **Using temporary**：

group by没用上索引，使用了临时表。（group by 包含order by）





#### **Using filesort**：

order by没有用上索引





#### **Using join buffer**：

关联字段没用上索引

![image-20211204172958893](%E4%BC%98%E5%8C%96.assets/image-20211204172958893.png)





USING index

Using where

impossible where

select tables optimized away









# 优化点

优化主要与索引、事务有关

## 批量插入数据

1. 关闭事务自动提交
2. 删除索引
3. mybatis框架的优化



## 对于索引的优化

主要看 explain的 type、extra两个字段

重点关注：

- key（查看有没有使用索引）
- key_len（查看索引使用是否充分）
- type（查看索引类型）
- Extra（查看附加信息：排序、临时表、where条件为false等）



  一般情况下根据这4列就能找到索引问题。



## 关联查询的优化

1. 保证被驱动表的 join实段已经被索引
2. left join时， 选择小表作为驱动表，大表作为被驱动表。
3. inner join时，mysql会自己帮你把小结果集的表选为驱动表。
4. 子查询尽量不要放在被驱动表，有可能使用不到索引。因为需要子查询结果作为虚拟表 virtual，虚拟表无法建立索引
5. 能够直接多表关联的尽量直接关联，不用子查询。



## 驱动表的选取

### 什么是驱动表

1. 当连接查询没有where条件时，左连接查询时，前面的表是驱动表，后面的表是被驱动表，右连接查询时相反，内连接查询时，哪张表的数据较少，哪张表就是驱动表
2. 当连接查询有where条件时，带where条件的表是驱动表，否则是被驱动表

### 为什么用小表驱动大表

关联查询类似如下的结构

```java
for (row1 : 驱动表) { // 行数为 x
    for (row2 : 被驱动表){
        if (conidtion == true){ // 行数为 y
            send client
        }
    }
}
```

时间复杂度为：（因为被驱动表用了索引）

> x*log(y)

由上公式可知，x必定为小表



## 子查询的优化

尽量不要使用not in 或者 not exists，使用left outer join on xxx is null替代

## order by优化

order by：必须要有过滤条件，才能用上索引

~~~sql
# 用不上索引
EXPLAIN SELECT SQL_NO_CACHE * FROM emp ORDER BY age,deptid;

# 用得上索引
EXPLAIN SELECT SQL_NO_CACHE * FROM emp ORDER BY age, deptid LIMIT 10; # 使用limit也能用索引
EXPLAIN SELECT FROM emp WHERE age=45 ORDER BY deptid;

~~~

顺序错，必排序

方向反，必排序

https://www.bilibili.com/video/BV12b411K7Zu?p=339

# 实例



# 优化技巧

[聊聊sql优化的15个小技巧 (qq.com)](https://mp.weixin.qq.com/s/Vv6IB9toAJ2AThdJxIOgqA)

sql语句在做一些耗时的操作之前，应尽可能缩小数据范围，这样能提升sql整体的性能。

1. 避免使用select *
2. 用union all代替union
3. 小表驱动大表
4. 批量操作
5. 多用limit
6. in中值太多
7. 增量查询
8. 高效的分页（逻辑分页）
9. 用连接查询代替子查询
10. join的表不宜过多，阿里巴巴开发者手册的规定，join表的数量不应该超过`3`个。
11. join时要注意（与inner、left join有关）
12. 控制索引的数量
13. 选择合理的字段类型
14. 提升group by的效率
15. 索引优化



## 1. 避免使用select *

在实际业务场景中，可能我们真正需要使用的只有其中一两列。查了很多数据，但是不用，白白浪费了数据库资源，比如：内存或者cpu。

此外，多查出来的数据，通过网络IO传输的过程中，也会增加数据传输的时间。

还有一个最重要的问题是：`select *`不会走`覆盖索引`，会出现大量的`回表`操作，而从导致查询sql的性能很低。

## 2. 用union all代替union

我们都知道sql语句使用`union`关键字后，可以获取排重后的数据。

而如果使用`union all`关键字，可以获取所有数据，包含重复的数据。

**排重的过程需要遍历、排序和比较，它更耗时，更消耗cpu资源**。

所以如果能用union all的时候，尽量不用union。





## 4. 批量操作

每次远程请求数据库，是会消耗一定性能的。

但需要注意的是，不建议一次批量操作太多的数据，如果数据太多数据库响应也会很慢。批量操作需要把握一个度，建议每批数据尽量控制在500以内。如果数据多于500，则分多批次处理。



## 5. 多用limit

有时候，我们需要查询某些数据中的第一条，比如：查询某个用户下的第一个订单，想看看他第一次的首单时间。

**反例：**

```sql
select id, create_date 
 from order 
where user_id=123 
order by create_date asc;
```

这种做法在功能上没有问题，但它的效率非常不高，需要先查询出所有的数据，有点浪费资源。

**正例：**

```sql
select id, create_date 
 from order 
where user_id=123 
order by create_date asc 
limit 1;
```



## 8. 高效的分页（逻辑分页）

反例：

```sql
select id,name,age 
from user limit 1000000,20;
```

mysql会查到1000020条数据，然后丢弃前面的1000000条，只查后面的20条数据，这个是非常浪费资源的。

那么，这种海量数据该怎么分页呢？

优化sql：

```sql
select id,name,age 
from user where id > 1000000 limit 20;
```

先找到上次分页最大的id，然后利用id上的索引查询。不过该方案，要求id是连续的，并且有序的。

还能使用`between`优化分页。

```sql
select id,name,age 
from user where id between 1000000 and 1000020;
```

需要注意的是between要在唯一索引上分页，不然会出现每页大小不一致的问题。



## 9. 用连接查询代替子查询

mysql中如果需要从两张以上的表中查询出数据的话，一般有两种实现方式：`子查询` 和 `连接查询`。

子查询的例子如下：

```sql
select * from order
where user_id in (select id from user where status=1)
```

子查询语句可以通过`in`关键字实现，一个查询语句的条件落在另一个select语句的查询结果中。程序先运行在嵌套在最内层的语句，再运行外层的语句。

子查询语句的优点是简单，结构化，如果涉及的表数量不多的话。

但缺点是**mysql执行子查询时，需要创建临时表，查询完毕后，需要再删除这些临时表，有一些额外的性能消耗。**

这时可以改成连接查询。具体例子如下：

```sql
select o.* from order o
inner join user u on o.user_id = u.id
where u.status=1
```





## 11.  join时小表驱动大表

如果两张表使用inner join关联，mysql会自动选择两张表中的小表，去驱动大表，所以性能上不会有太大的问题。

使用left join的示例如下：

```sql
select o.id,o.code,u.name 
from order o 
left join user u on o.user_id = u.id
where u.status=1;
```

如果两张表使用left join关联，mysql会默认用left join关键字左边的表，去驱动它右边的表。如果左边的表数据很多时，就会出现性能问题。

> 要特别注意的是在用left join关联查询时，左边要用小表，右边可以用大表。如果能用inner join的地方，尽量少用left join。



## 12. 控制索引的数量

mysql使用的B+树的结构来保存索引的，在insert、update和delete操作时，需要更新B+树索引。如果索引过多，会消耗很多额外的性能。

阿里巴巴的开发者手册中规定，单表的索引数量应该尽量控制在`5`个以内，并且单个索引中的字段数不超过`5`个。

那么，问题来了，如果表中的索引太多，超过了5个该怎么办？

这个问题要辩证的看，如果你的系统并发量不高，表中的数据量也不多，其实超过5个也可以，只要不要超过太多就行。

但对于一些高并发的系统，请务必遵守单表索引数量不要超过5的限制。

那么，高并发系统如何优化索引数量？

**能够建联合索引，就别建单个索引，可以删除无用的单个索引。**

将部分查询功能迁移到其他类型的数据库中，比如：Elastic Seach、HBase等，在业务表中只需要建几个关键索引即可。



## 13. 选择合理的字段类型

我们在选择字段类型时，应该遵循这样的原则：

1. 能用数字类型，就不用字符串，因为字符的处理往往比数字要慢。
2. 尽可能使用小的类型，比如：用bit存布尔值，用tinyint存枚举值等。
3. 长度固定的字符串字段，用char类型。
4. 长度可变的字符串字段，用varchar类型。
5. 金额字段用decimal，避免精度丢失问题。



## 14. 提升group by的效率

我们有很多业务场景需要使用`group by`关键字，它主要的功能是去重和分组。

通常它会跟`having`一起配合使用，表示分组后再根据一定的条件过滤数据。

**反例：**

```sql
select user_id,user_name from order
group by user_id111
having user_id <= 200;
```

这种写法性能不好，它先把所有的订单根据用户id分组之后，再去过滤用户id大于等于200的用户。

分组是一个相对耗时的操作，为什么我们不先缩小数据的范围之后，再分组呢？

**正例：**

```sql
select user_id,user_name from order
where user_id <= 200
group by user_id
```

使用where条件在分组前，就把多余的数据过滤掉了，这样分组时效率就会更高一些。

> 其实这是一种思路，不仅限于group by的优化。我们的sql语句在做一些耗时的操作之前，应尽可能缩小数据范围，这样能提升sql整体的性能。

